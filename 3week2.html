<!DOCTYPE html>
<html>
    <head>
        <title>프로그래밍 기초 3주차</title>
        <link href="studystyle.css" type="text/css" rel="stylesheet">
    </head>
    <body>
        <header><h2>3주차 과제 (2)</h2></header>
        <nav class="navbar">
            <ul class="menu">
            <li class="nav-item"><a href="1week1.html">week1(1)</a>
            <li class="nav-item"><a href="1week2.html">week1(2)</a>
            <li class="nav-item"><a href="2week1.html">week2(1)</a>
            <li class="nav-item"><a href="2week2.html">week2(2)</a>
            <li class="nav-item"><a href="3week1.html">week3(1)</a>
            <li class="nav-item"><a href="3week2.html">week3(2)</a>
            </ul>
        </nav>
        <nav class="side"><ul class="sideul">
            <li class="side-item"><a href="#cheat">치트엔진과 인증크랙의 원리</a>
            <li class="side-item"><a href="#cpu">CPU 스케쥴링과 상태전이도</a>
            <li class="side-item"><a href="#server">서버-소켓 구조</a>
            <li class="side-item"><a href="#client">클라이언트-소켓 구조</a>
            <li class="side-item"><a href="#socket">파일 디스크립터(소켓)</a>
            <li class="side-item"><a href="#thread">시스템 쓰레드</a>
            <li class="side-item"><a href="#load">로드 밸런싱</a>
            <li class="side-item"><a href="#web">웹 서버</a>
            <li class="side-item"><a href="#http">HTTP 1.0과 1.1</a>
            <li class="side-item"><a href="#https">HTTPS (SSL/TLS)</a>
        </ul></nav>
        <section>
            <div id="cheat">
                <h3><strong>치트엔진과 인증크랙의 원리</strong></h3>
                <b><ins>치트엔진의 원리</ins></b><br>
                    <p>: 치트엔진은 게임에서 게임 내의 변수나 상태를 조작하기 위해 사용되는 도구이다. <br>
                        <ul><li>메모리 스캔 : 게임이 실행 중인 프로세스의 메모리를 스캔하여 원하는 값을 찾는다. 주로 헥스 에디터와 같은 도구를 사용한다.
                            <li>값 탐색 : 스캔된 메모리에서 특정 값을 탐색하여 원하는 변수 또는 상태를 찾는다. 이 값을 변경함으로써 게임의 동작을 조작할 수 있다.
                            <li>메모리 패치 : 찾은 값을 변경하여 게임의 동작을 원하는대로 수정한다.
                            <li>메모리 주소 잠금 : 원하는 변수 또는 상태를 찾았다면, 해당 메모리 주소를 잠금(lock)하여 추후에도 접근하고 값을 변경할 수 있도록 한다.
                            <li>게임 실행 동안 값 모니터링 : 잠긴 메모리 주소를 계속 모니터링하면서 값이 변경되었을 때 즉각적으로 대응하여 원하는 조작을 유지한다.
                        </ul>
                    </p><br>
                <b><ins>인증크랙의 원리</ins></b><br>
                    <p>: 인증크래근 소프트웨어나 게임의 복제품에서 보호 메커니즘을 우회하여 라이선스 인증을 필요로 하지 않고 사용할 수 있게 하는 것을 의미한다. 
                        <ul><li>라이선스 체크 우회 : 소프트웨어나 게임은 일반적으로 라이선스 키, 시리얼 번호, 인증 파일 등을 사용하여 라이선스 인증을 수행한다. 
                            인증 크랙은 체크 메커니즘을 우회하거나 조작하여 정상적으로 인증되었다고 가장하도록 한다.
                            <li>보호 메커니즘 우회 : 복제 방지 기술을 사용하여 복제품의 실행을 방지하려는 보호 메커니즘을 우회하거나 해제하여 프로그램을 실행 가능하게 한다.
                            <li>수정된 실행 파일 : 소프트웨어나 게임의 실행 파일을 분석하여 인증 관련 코드를 수정하거나 제거한다.
                            <li>키젠(Keygen) : 일부 인증 크랙은 라이선스 키를 생성하는 키젠이라는 도구를 사용한다. 키젠은 유효한 라이선스 키를 생성하여 프로그램을 정상적으로 
                            인증하는 역할을 한다.
                        </ul>
                    </p><br>
            </div><hr>
            <div id="cpu">
                <h3><strong>CPU 스케쥴링과 상태전이도</strong></h3>
                <p>: CPU 스케쥴링(CPU Scheduling)은 운영체제에서 여러 프로세스들이 CPU 사용하는 순서를 결정하는 방법이다. <br>
                    CPU 스케쥴링은 프로세스의 실행 상태 전이를 관리한다. 상태 전이는 프로세스가 다음 상태로 전환되는 과정을 의미한다.
                </p>
                <details><summary>CPU 스케쥴링 알고리즘</summary>
                    <ul>
                        <li>선입선출(FCFS : First-Come, First-Served) : 먼저 도착한 프로세스에게 CPU를 할당한다. 비선점 스케쥴링 알고리즘이며 평균 대기 시간이 길어질 수 있다. 
                        <li>최단 작업 우선(SJF : Shortest Job First) : 도착한 프로세스들 중 실행 시간이 가장 짧은 작업을 우선으로 실행한다. 작업의 실행 시간을 정확하게 예측해야해서 실제로는 사용하기 어렵다.
                        <li>우선순위(Priority) : 프로세스에 우선순위를 할당하고 우선순위가 가장 높은 프로세스에게 CPU를 할당한다. 선점/비선점 형태로 구현할 수 있고, 우선순위가 고정되거나 동적으로 변경될 수 있다.
                        <li>라운드 로빈(Round Robin) : 시간 할당량을 정하여 각 프로세스에게 순서대로 CPU를 할당하고 할당된 시간이 지나면 다른 프로세스로 전환한다. 선점 형태이며, 시분할 시스템에서 사용된다.
                        <li>다단계 큐(Multi-level Queue) : 프로세스들을 여러 개의 큐로 구분하고, 각 큐에 다른 스케쥴링 알고리즘을 적용한다.
                        </ul>
                </details>
                <details><summary>상태전이도</summary>
                    <a href="https://blog.skby.net/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EC%A0%84%EC%9D%B4/"><img src="https://i0.wp.com/blog.skby.net/wp-content/uploads/2019/04/1-31.png?w=570&ssl=1"></a>
                    <ul><li>Dispatch : 준비 -> 실행
                        <li>Timeout : 실행 -> 준비
                        <li>Block : 실행 -> 슬립
                        <li>Wake up : 슬립 -> 준비 (필요한 자원이 할당되었을 때)
                        <li>Swap-out(suspend) : 준비 -> 지연 대기 -> 지연
                        <li>Swap-in(resume) : 지연 -> 준비 지연-> 대기
                        <li>Suspend / Resume : 지연 대기 상태
                        </ul>
                </details>
            </div><hr>
            <div id="server">
                <h3><strong>서버-소켓 구조</strong></h3>
                <p>: 네트워크 통신에서 서버와 클라이언트 간의 상호작용을 위한 구조이다. 클라이언트가 서버에 요청을 보내고, 서버가 해당 요청에 응답하는 
                    방식으로 동작한다. 서버(항상 실행 중, 클라이언트의 요청 기다리고 처리하는 역할), 소켓(서버와 클라이언트 간의 통신 가능하게 하는 네트워크 인터페이스), 
                    클라이언트(서버에 요청 보내는 컴퓨터 또는 프로그램)
                </p>
                <details><summary>서버-소켓 구조의 동작</summary>
                    <ul><ol type="1">
                        <li>서버는 소켓을 생성, 지정된 포트 번호에서 클라이언트의 연결 요청을 대기
                        <li>클라이언트는 서버의 IP 주소와 포트 번호를 사용하여 소켓에 접속
                        <li>클라이언트는 서버에 요청을 전송, 해당 요청은 서버의 소켓을 통해 도착
                        <li>서버는 클라이언트의 요청을 수신, 필요한 처리를 수행한 후 응답 생성
                        <li>서버는 소켓을 통해 클라이언트에게 응답 전송
                        <li>클라이언트는 서버의 응답을 수신, 필요한 처리를 수행
                        <li>클라이언트와 서버 간 통신이 끝나면 소켓 연결 닫음
                    </ol></ul>
                </details>
            </div><hr>
            <div id="client">
                <h3><strong>클라이언트-소켓 구조</strong></h3>
                <p>: 네트워크 통신에서 클라이언트가 서버에 연결하여 요청을 보내고 서버가 해당 요청에 대한 응답을 받는 구조이다. 클라이언트가 서버와 상호작용하는 방식으로 
                    동작하고, 클라이언트(네트워크에서 서비스를 사용하는 주체, 요청 보내고 응답 받는 컴퓨터/프로그램), 소켓(클라이언트와 서버 간의 통신 위한 네트워크 인터페이스), 
                    서버(클라이언트 요청 받아 처리, 응답 제공하는 컴퓨터/프로그램)로 구성된다.
                </p>
                <details><summary>클라이언트-소켓 구조의 동작</summary>
                    <ul><ol type="1">
                        <li>클라이언트는 소켓을 생성, 서버의 IP 주소와 포트 번호를 사용해 소켓에 연결
                        <li>클라이언트는 서버에 요청을 전송, 요청은 소켓을 통해 서버로 전달
                        <li>서버는 클라이언트의 요청을 수신, 해당 요청을 처리하여 응답 생성
                        <li>서버는 소켓을 통해 클라이언트에게 응답 전송
                        <li>클라이언트는 서버의 응답을 수신, 필요한 처리 수행
                    </ol></ul>
                </details>
            </div><hr>
            <div id="socket">
                <h3><strong>파일 디스크립터(소켓)</strong></h3>
                <p>: 파일 디스크립터(File Descriptor)는 운영체제에서 파일이나 소켓과 같은 입출력 리소스를 식별하기 위해 사용되는 정수 값이다. 
                    운영체제가 해당 리소스를 추적하고 관리하는 데 사용된다. 일반적으로 양수의 정수 값으로 표현되며, 0 이상의 값은 유효한 파일 디스크립터를 
                    나타내고, -1은 오류 또는 무효한 파일 디스크립터를 나타낸다. 파일 디스크립터는 프로세스의 파일 테이블에 저장되는데, 이 테이블은 프로세스가 열린 파일이나 
                    소켓을 추적하는 데 사용된다.
                </p>
                <details><summary>파일 디스크립터 사용되는 상황</summary>
                    <ul>
                        <li>파일 입출력 : 파일을 열고 읽거나 쓸 수 있다.
                        <li>네트워크 통신 : 소켓은 파일과 유사한 입출력 리소스로 취급된다. 소켓에 대한 파일 디스크립터를 생성하여 소켓을 식별하고, 소켓을 통한 네트워크 통신을 수행한다. 
                            파일 디스크립터를 사용해 소켓에 데이터를 쓰거나 읽을 수 있다.
                        <li>파이프 및 FIFO(First-In First-Out) : 프로세스 간 통신을 위한 매개체로 사용되는 파이프와 FIFO에 파일 디스크립터를 사용해 데이터를 쓰거나 읽을 수 있다.
                    </ul>
                </details>
            </div><hr>
            <div id="thread">
                <h3><strong>시스템 쓰레드</strong></h3>
                <p>: 시스템 쓰레드(System Thread)란 컴퓨터 시스템의 핵심적인 기능과 작업을 수행하기 위해 운영체제에서 생성하고 관리하는 쓰레드를 말한다. 
                    즉, 운영체제의 일부분이며 사용자가 직접적으로 제어할 수 없다. 시스템 쓰레드는 운영체제의 내부 동작과 프로세스 관리, 시스템 자원 할당, 인터럽트 처리 
                    등과 같은 중요한 역할을 수행하며, 응용 프로그램의 제어 하에 생성되고 관리되는 사용자 쓰레드와는 다르게 시스템 쓰레드는 운영체제에 의해 
                    직접 관리되어 더 높은 권한과 우선순위를 갖는다. 주로 커널 모드에서 실행된다. 
                </p>
                <details><summary>주요 시스템 쓰레드 종류</summary>
                <ul>
                    <li>스케쥴링 쓰레드
                    <li>인터럽트 핸들러 쓰레드
                    <li>메모리 관리 쓰레드
                    <li>파일 시스템 쓰레드
                    </ul>
                </details>
            </div><hr>
            <div id="load">
                <h3><strong>로드 밸런싱</strong></h3>
                <p>: 로드 밸런싱은 애플리케이션을 지원하는 리소스 풀 전체에 네트워크 트래픽을 균등하게 배포하는 방법이다. 
                    데이터가 중복되는 리소스 서버(많은 양의 트래픽을 처리하기 위해 존재)를 동일하게 사용되도록 하는 디바이스가 로드 밸런싱이다.
                </p>
                <details><summary>로드 밸런싱 이점</summary>
                <ul><li>가용성 : 서버 문제를 자동으로 감지하고 클라이언트 트래픽을 사용 가능한 서버로 리디렉션하여 시스템의 내결함성을 높인다.
                    <li>확장성 : 여러 서버 간에 네트워크 트래픽을 지능적으로 전달할 수 있어 수천 개의 클라이언트 요청을 처리할 수 있다.
                    <li>보안 : 인터넷 애플리케이션에 또 다른 보안 계층을 추가할 수 있는 보안 기능이 내장되어 있어 분산 서비스 거부 공격을 처리하거나 악성 콘텐츠를 차단하는 등을 수행할 수 있다.
                    <li>성능 : 응답 시간을 늘리고 네트워크 지연 시간을 줄여 애플리케이션 성능을 향상시킨다.
                    </ul>
                </details>
            </div><hr>
            <div id="web">
                <h3><strong>웹 서버</strong></h3>
                <p>: 웹 서버(Web Server)는 클라이언트로부터 HTTP 요청을 받아들이고, 정적 컨텐츠(단순 HTML, CSS, 이미지, 파일 등)를 제공하는 소프트웨어이다. 
                    웹 서버가 정적 컨텐츠가 아닌 동적 컨텐츠를 요청받으면 WAS에게 해당 요청을 넘긴다. 웹 서버에는 Apache, NginX 등이 있다.
                </p>
                <details><summary>웹 서버 공통 기능</summary>
                <ul><li>virtual hosting : 하나의 IP 주소를 사용하는 많은 웹 사이트들을 지원
                    <li>large file support : 32 bit OS에서 2GB 이상의 파일을 지원
                    <li>bandwidth throttling : 네트워크의 포화상태를 방지하기 위한 응답 속도 제한
                    <li>server-side scripting : 웹 서버 단에서 실행되는 다이나믹 웹 페이지 생성 언어 지원
                </ul>
                </details>
            </div><hr>
            <div id="http">
                <h3><strong>HTTP 1.0과 1.1</strong></h3>
                <p>: 우선 HTTP(Hyper Text Transfer Protocol)는 인터넷에서 주로 사용하는 데이터를 송수신하기 위한 프로토콜이다. 
                </p>
                <b><ins>HTTP 1.0과 1.1의 차이</ins></b><br>
                <a href="https://code-lab1.tistory.com/196"><img src="https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fw77D5%2FbtrysCLUmNX%2FCrTBAmxrKsSNyWA5VeYimk%2Fimg.webp"></a>
                <ul><li>연결의 지속성 : HTTP는 기본적으로 TCP를 이용하여 통신하는데, HTTP 1.0은 TCP 세션을 유지하지 않고, 1.1은 TCP 세션을 유지한다. 
                    따라서 HTTP 1.0은 매번 데이터를 요청, 수신할 때마다 새로운 TCP 세션을 맺어야 하는 Non-persistent이고, HTTP 1.1은 한번의 TCP 세션에 여러 개의 요청을 보내고 응답을 수신할 수 있는 Persistent이다. 
                    <li>파이프라이닝 : HTTP 1.0은 파이프라이닝을 제공하지 않지만 HTTP 1.1은 파이프라이닝 기능을 제공한다. (파이프라이닝 : 송신자가 다수의 패킷을 한번에 보내는 것)
                    <li>호스트 헤더 : HTTP 1.0은 하나의 IP 주소에 여러 개의 도메인을 운영할 수 없어 도메인 별로 IP를 구분해서 준비해야하는데, HTTP 1.1은 가상 호스팅이 가능해져 하나의 IP 주소에 여러 개의 도메인을 적용시킬 수 있다.
                    <li>향상된 인증 절차 : HTTP 1.1에서는 proxy-authentication, proxy-authorization 2개의 header가 추가되어 프록시가 사용자의 인증을 요구하는 것이 가능해져서 인증 절차가 향상되었다.
                </ul>
            </div><hr>
            <div id="https">
                <h3><strong>HTTPS(SSL/TLS)</strong></h3>
                <p>: HTTPS(Hypertext Transfer Protocol Secure)은 HTTP의 보안 버전이다. HTTPS는 SSL(Secure Sockets Layer) 또는 TLS(Transport Layer Security) 프로토콜을 
                    사용하여 웹 브라우저와 웹 서버 간의 통신을 암호화하는 보안 프로토콜이다. <br>
                    HTTPS의 주요 목적은 데이터의 기밀성과 무결성을 보장하여 민감한 정보를 안전하게 전송하는 것으로, 데이터를 암호화하여 누구나 쉽게 해석할 수 없도록 만들어주고, 
                    데이터의 변조를 탐지할 수 있도록 한다. <br>
                    HTTPS는 인증서의 검증과 암호화 키 생성 등의 추가 작업으로 인해 일반 HTTP보다 약간의 오버헤드가 발생할 수 있으나 데이터 보안과 민감한 정보의 보호를 위해 널리 사용된다. 
                </p>
                <details><summary>HTTPS 작동 방식</summary>
                <ul><li>클라이언트가 HTTPS로 액세스하는 웹 사이트에 접속하면 웹 서버는 클라이언트에게 공개키 인증서를 제공
                    <li>웹 브라우저는 서버의 공개키를 사용해 인증서를 검증, 서버의 신원을 확인, 인증서가 유효하지 않거나 변조되었다면 웹 브라우저는 경고를 표시하거나 연결을 종료
                    <li>클라이언트와 서버는 TLS/SSL 핸드셰이크를 수행하여 공유 암호화 키를 생성, 암호화된 연결이 성립, 이후 데이터는 암호화된 연결을 통해 주고받는다.
                    <li>이후 클라이언트와 서버 간의 모든 데이터는 암호화되어 전송, 중간에 제 3자가 데이터를 엿볼 수 없도록 보호
                </ul></details>
            </div><hr>
        </section>
        <footer><h4>참고</h4>
            <ul><li>https://blog.skby.net/%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%81%ED%83%9C-%EC%A0%84%EC%9D%B4/
                <li>https://aws.amazon.com/ko/what-is/load-balancing/
                <li>https://code-lab1.tistory.com/199
                <li>https://dataonair.or.kr/db-tech-reference/d-lounge/expert-column/?mod=document&uid=52353
                <li>https://code-lab1.tistory.com/196
                <li>ChatGPT
                <li><a href="3week1.html">3주차 첫번째 페이지로 이동</a>
            </ul>
        </footer>
    </body>
</html>