<!DOCTYPE html>
<html>
    <head>
        <title>프로그래밍 기초 3주차</title>
        <link href="studystyle.css" type="text/css" rel="stylesheet">
    </head>
    <body>
        <header><h2>3주차 과제 (1)</h2></header>
        <nav class="navbar">
            <ul class="menu">
            <li class="nav-item"><a href="1week1.html">week1(1)</a>
            <li class="nav-item"><a href="1week2.html">week1(2)</a>
            <li class="nav-item"><a href="2week1.html">week2(1)</a>
            <li class="nav-item"><a href="2week2.html">week2(2)</a>
            <li class="nav-item"><a href="3week1.html">week3(1)</a>
            <li class="nav-item"><a href="3week2.html">week3(2)</a>
            </ul>
        </nav>
        <nav class="side"><ul class="sideul">
            <li class="side-item"><a href="#go">GO 언어</a>
            <li class="side-item"><a href="#rust">RUST 언어</a>
            <li class="side-item"><a href="#pointer">포인터(*)와 참조(&)의 차이</a>
            <li class="side-item"><a href="#lambda">함수 포인터와 람다(익명) 함수</a>
            <li class="side-item"><a href="#callback">콜백 함수와 콜백 지옥</a>
            <li class="side-item"><a href="#void">void 포인터와 malloc</a>
            <li class="side-item"><a href="#nasm">nasm과 AT&T</a>
            <li class="side-item"><a href="#endian">빅 엔디안과 리틀 엔디안</a>
            <li class="side-item"><a href="#reversing">파일 리버싱</a>
            <li class="side-item"><a href="#binary">바이너리 코드와 보는 방법</a>
        </ul></nav>
        <section>
            <div id="go">
                <h3><strong>GO 언어</strong></h3>
                <p>: Google에서 개발한 오픈 소스 프로그래밍 언어로, C와 유닉스 운영체제의 영향을 받았으며, 
                    동시성을 강조하는 특징을 가지고 있다. C의 영향은 받았지만 다르기 때문에 커널이나 장치 드라이버, 임베디드 
                    소프트웨어 같은 저수준 프로그램에는 적합하지 않고, 상용 하드웨어 전용으로 설계되어 하드웨어 가속을 사용할 수 없어 
                    그래픽스 분야에는 맞지 않다. 즉, 유틸리티나 네트워크 서비스와 같은 프로그램을 만들 때 유용하다. 
                    </p>
                <details><summary>GO 언어 주요 특징</summary>
                    <ul>
                        <li>간결한 문법 : 시스템 프로그래밍에 적합하도록 설계되었으며, C와 구문은 비슷하지만 복잡도를 낮추고 컴파일 속도 향상을 위해 소스 자체를 패키지화해 컴파일 속도를 향상시켰다.
                        <li>유틸리티 제공 : IDE(Integrated Development Environment)에서 쉽게 환경을 구성할 수 있다. 소스에 기술된 패키지 단위로 관리되며 필요한 외부 패키지를 get 커맨드로 받아와 사용할 수 있는 등 여러 가지 기능을 제공한다. 
                        <li>다양한 패키지 : 기본 패키지 이외에도 여러 벤더에서 다양한 패키지를 제공한다. http 패키지, 암호화 모듈이 기본 내장되어 있어 웹 서버를 쉽게 구축할 수 있고, cgo라는 별도 지시자를 설정함으로써 C언어로 작성된 라이브러리를 사용할 수 있다. 
                        <li>동시성(Concurrency) : 서버 개발용으로 설계된 GO 언어는 쉽게 프로그래밍 할 수 있도록 고루틴과 채널을 제공한다. 이를 활용해 멀티코어 환경에서 병렬 처리를 쉽게 구현할 수 있다. 
                        <li>에러 처리 : GO 언어에서 함수는 복수 개의 값을 반환할 수 있어 에러가 발생했을 때 일반적인 리턴과 함께 오류 메시지를 반환할 수 있고, 이로인해 에러 처리를 쉽게 할 수 있다. 
                    </ul></details>
            </div><hr>
            <div id="rust">
                <h3><strong>RUST 언어</strong></h3>
                <p>: Mozilla가 개발한 시스템 프로그래밍 언어로 안정성, 속도, 병렬 처리 등을 강조한다. RUST는 메모리 안전성과 데이터 경쟁 조건을 방지하기 
                    위한 강력한 보증 시스템을 제공하며, C와 C++의 대체 언어로 주목받는다. 
                </p>
                <details><summary>RUST 언어 주요 특성</summary>
                    <ul>
                        <li>안전성 : 메모리 안전성을 강조하는 언어인 Rust는 프로그램이 메모리 오류나 데이터 경쟁 조건으로부터 안전하게 실행될 수 있도록 한다. 보증 시스템을 통해 컴파일 타임에 오류를 검출하고, 런타임에 메모리 안전성을 유지한다. 이로써 많은 프로그래밍 오류를 사전에 방지할 수 있다. 
                        <li>병렬 처리 : 안전한 동시성 프로그래밍을 위한 동기화 원시 타입과 스레드 간 메시지 전달을 지원, 병렬 실행을 위한 고수준 추상화도 제공한다. 
                        <li>빠른 실행 속도 : Rust의 컴파일러는 높은 수준의 최적화를 수행하여 빠른 실행 속도를 달성할 수 있고, 메모리 안전성은 런타임 오버헤드 없이 컴파일 타임에 확인되므로 안정성과 성능 모두 얻을 수 있다. 
                        <li>멀티패러다임 : 함수형 프로그래밍과 객체지향 프로그래밍의 요소를 결합한 멀티패러다임 언어이다. 패턴 매칭, 클로저, 제네릭 등 다양한 기능을 제공하여 유연하고 표현력 있는 코드를 작성할 수 있다. 
                        <li>크로스 플랫폼 지원 : 여러 플랫폼에서 동작하는 크로스 플랫폼 언어로 Windows, macOS, Linux 등 다양한 운영체제에서 사용할 수 있다. 
                    </ul>
                </details>
            </div><hr>
            <div id="pointer">
                <h3><strong>포인터(*)와 참조(&)의 차이</strong></h3>
                <ul><li>사용 방법 : 포인터는 변수 앞에 *를 사용하여 선언, 변수의 주소를 가리키는 값을 저장한다. 참조는 변수 앞에  &를 사용하여 선언, 다른 변수에 대한 참조를 생성한다.
                    <li>역참조 : 포인터는 역참조 연산자(*)를 사용하고, 참조는 자동으로 역참조되어 원래 변수에 직접 접근할 수 있다.
                    <li>초기화 : 포인터는 NULL 값이나 유효한 주소로 초기화해야하고, 참조는 선언과 동시에 반드시 초기화해야 한다.
                    <li>Null 값 : 포인터는 NULL 값을 가질 수 있어서 아무것도 가리키지 않을 수 있다. 참조는 반드시 유효한 변수를 참조해야 하며, NULL 값은 가질 수 없다.
                    <li>재할당 : 포인터는 다른 주소로 재할당할 수 있다. 참조는 한 번 선언되면 다른 변수를 참조할 수 없으며, 참조된 변수를 변경하는 것이 해당 참조 변수를 변경하는 것과 동일하다.
                    <li>사용되는 언어 : 포인터는 C, C++, Rust와 같은 언어에서 주로 사용되고, 참조는 C++, Rust와 같은 언어에서 사용된다. C언어에는 참조가 없는 대신 포인터를 사용한다.
                </ul>
                <details><b><ins>포인터(*)</ins></b><br>
                    <p>: 변수가 메모리 주소를 가리키는 값을 저장하는 변수이다. 포인터는 특정 변수의 주소를 저장하고, 해당 주소에 저장된 값을 역참조하여 
                        변수의 값을 읽거나 수정할 수 있다. 직접적인 메모리 주소를 다루기 때문에 잘못 사용하면 메모리 오류가 발생할 수 있어 주의가 필요하다.
                    </p>
                </details>
                <details><b><ins>참조(&)</ins></b><br>
                    <p>: 변수의 메모리 주소를 가져와서 다른 변수에 연결하는 데 사용된다. 포인터와 유사한 기능을 제공하지만 일부 제한이 있다. 
                        변수에 대한 별칭(alias)을 만들어주며, 원래 변수와 참조 변수는 메모리 주소를 공유한다. 따라서 참조를 통해 값을 변경하면 원래의 변수 값도 변경된다.
                    </p>
                </details>
            </div><hr>
            <div id="lambda">
                <h3><strong>함수 포인터와 람다(익명) 함수</strong></h3>
                <p>: 함수 포인터와 람다 함수는 프로그래밍에서 함수를 다루는 데 사용되는 개념이다.</p>
                <b><ins>함수 포인터</ins></b><br>
                <p>: 메모리에서 함수의 주소를 가리키는 변수로 C, C++, Rust 등에서 주로 사용된다. 함수 포인터를 사용하면 프로그램은 런타임에 동적으로 함수를 선택하거나 
                    호출할 수 있다. 함수를 일급 객체로 다루는 함수형 프로그래밍과 유사한 기능을 제공한다. <br>
                    함수 포인터 선언 방법 : returnType (*pointerName)(parameterTypes)
                </p><br>
                <b><ins>람다(익명) 함수</ins></b><br>
                <p>: 람다 함수는 익명 함수(이름을 가질 필요 없는 함수)로, 주로 함수형 프로그래밍 언어에서 지원되며 C++, Python, JavaScript 등에서 사용할 수 있다. 
                    람다 함수는 코드 블록을 작성하고 해당 블록을 변수에 할당하거나 함수 호출 시에 바로 사용할 수 있다. 또한 외부 범위의 변수를 캡처하여 사용할 수 있어 
                    람다 함수 내에서 외부 변수를 읽거나 수정할 수 있다. <br>
                    람다 함수 일반적인 구문 : [captures](parameters) -> returnType { // 함수의 내용}
                </p><br>
            </div><hr>
            <div id="callback">
                <h3><strong>콜백 함수와 콜백 지옥</strong></h3>
                <p>: 콜백 함수(Callback function)는 다른 함수에게 인수로 전달되어 나중에 호출되는 함수이다. 비동기적인 이벤트 처리, 
                    이벤트 핸들링, 프로그램의 흐름 제어 등 다양한 상황에서 사용된다. 일반적으로 인터페이스를 통해 정의되며 해당 인터페이스에 맞게 
                    동작하는 함수를 사용자가 직접 구현해야 한다. <br>
                    콜백 지옥(Callback hell)은 비동기적인 코드에서 콜백 함수를 중첩하여 사용할 때 발생하는 코드의 복잡성과 가독성 저하를 뜻한다. 
                    콜백 함수를 중첩하게 되면 코드의 들여쓰기 수준이 깊어지고, 코드의 흐름을 이해하기 어려워진다. 
                </p>
                <details><summary>콜백 지옥 일반적인 해결법</summary>
                    <ul>
                        <li>Promise : 비동기 작업의 결과를 대기하고 처리하기 위한 패턴, 콜백 지옥을 방지하기 위해 비동기 코드를 보다 선형적으로 작성할 수 있게 도와준다.
                        <li>Async/Await : Promise 패턴을 기반으로 하는 문법적인 개선, Async 함수 내에서 Await 키워드를 사용해 비동기 작업의 결과를 동기적으로 처리할 수 있게 하여 코드의 가독성을 향상시키고 콜백 지옥을 피한다.
                        <li>콜백 체이닝 : 콜백 함수를 중첩하지 않고도 비동기 작업을 순차적으로 처리하는 방법, Promise나 Async/Await와 같은 기술 사용해 작성할 수 있다.
                    </ul>
                </details>
            </div><hr>
            <div id="void">
                <h3><strong>void 포인터와 malloc</strong></h3>
                <p>: void 포인터와 malloc() 함수를 함께 사용하여 동적 메모리 할당을 수행하면 프로그램이 실행 중에 필요한 메모리를 동적으로 할당하고 사용할 수 있다. 이를 통해 
                    프로그램의 유연성과 효율성을 높일 수 있다. 단, 메모리 할당 후에는 해제를 해야 한다. 
                </p><br>
                <b><ins>void 포인터</ins></b><br>
                <p>: C 언어에서 사용되는 특수한 포인터 타입이다. 어떤 타입의 주소든 가리킬 수 있으며, 포인터 산술 연산을 제외한 대부분의 포인터 연산을 수행할 수 
                    없다. 주로 동적 메모리 할당과 포인터 간의 형 변환에 사용된다.
                </p>
                <b><ins>malloc</ins></b><br>
                <p>: C 언어에서 동적 메모리 할당을 위해 사용되는 함수이다. 메모리에서 원하는 크기의 블록을 할당하고, 해당 블록의 시작 주소를 반환한다. 할당된 메모리 블록은 
                    void 포인터로 가리킬 수 있으며, 필요한 경우 해당 포인터를 다른 타입으로 형 변환하여 사용할 수 있다.
                </p>
            </div><hr>
            <div id="nasm">
                <h3><strong>nasm과 AT&T</strong></h3>
                <b><ins>nasm</ins></b><br>
                <p>: nasm(Netwide Assembler)은 x86 아키텍처를 위한 어셈블리 언어로 개발된 오픈 소스 어셈블러이다. Intel 문법을 사용하여 어셈블리 코드를 작성하고, 바이너리 
                    실행 파일을 생성 하는 데 사용된다. 플랫폼 간 이식성과 확장성이 뛰어나며 다양한 운영체제에서 사용될 수 있다. <br>
                    nasm은 간결하고 직관적인 구문을 가지고 있으며, 많은 기능과 지시어를 제공한다. 그 중 하나는 매크로 기능으로 이를 활용해 반복적인 코드 블록을 정의하고 재사용할 수 있다.
                </p><br>
                <b><ins>AT&T</ins></b><br>
                <p>: AT&T 문법은 다양한 어셈블러에서 사용되는 대안 어셈블리 문법으로, 주로 Unix 및 Unix-like 시스템에서 사용되며, GNU 어셈블러(GAS)와 함께 사용되는 경우가 많다. <br>
                    AT&T 문법은 명령어와 오퍼랜드가 역순으로 작성되며 오퍼랜드 앞에 $을 사용하여 즉시 값임을 나타내고, 주소를 나타내기 위해 %를 사용한다. 그리고 상수는 $를 사용하여 표현한다.
                </p>
            </div><hr>
            <div id="endian">
                <h3><strong>빅 엔디안과 리틀 엔디안</strong></h3>
                <p>: 빅 엔디안(Big Endian)과 리틀 엔디안(Little Endian)은 컴퓨터에서 메모리와 데이터를 표현하는 방식을 나타내는 개념이다. 엔디안은 바이트 순서를 의미하며, 컴퓨터 아키텍처에서 
                    데이터를 저장하고 전송하는 방법을 결정한다.
                </p>
                <b><ins>빅 엔디안</ins></b><br>
                <p>: 가장 상위 바이트를 가장 작은 메모리 주소에 저장하는 방식이다. 다중 바이트 데이터의 가장 상위 바이트가 가장 작은 주소에 저장되므로 주소 값이 증가할수록 낮은 자릿수에 해당하는 바이트가 
                    저장된다. 빅 엔디안은 네트워크 통신에서 주로 사용되는 표준 방식이다. (예 : TCP/IP 프로토콜)
                </p><br>
                <b><ins>리틀 엔디안</ins></b><br>
                <p>: 가장 상위 바이트를 가장 큰 메모리 주소에 저장하는 방식이다. 다중 바이트 데이터의 가장 상위 바이트가 가장 큰 주소에 저장되므로 주소 값이 증가할수록 높은 자릿수에 
                    해당하는 바이트가 저장된다. x86 아키텍처를 비롯한 많은 컴퓨터 시스템에서 사용되는 기본 방식이다.
                </p><br>
            </div><hr>
            <div id="reversing">
                <h3><strong>파일 리버싱</strong></h3>
                <p>: 파일 리버싱(File Reversing)은 컴퓨터 프로그램이나 파일의 내부 동작을 이해하기 위해 해당 파일을 분석하고 해석하는 과정을 뜻한다. 보안 연구, 악성 코드 분석, 디지털 
                    포렌식, 소프트웨어 역공학 등 다양한 분야에서 사용되며 주로 실행 파일, 바이너리 파일, 펌웨어, 드라이버 등을 대상으로 한다.
                </p><br>
                <details><summary>파일 리버싱 절차</summary>
                <ul><ol type="1">
                    <li>정적 분석 : 파일의 바이너리 코드를 분석하여 구조, 흐름, 데이터 구조, 알고리즘 등을 이해한다. 이를 위해 어셈블리 코드, 기계어, 파일 포맷, 헤더 정보 등을 분석한다.
                    <li>동적 분석 : 파일을 실행하고 실행 중에 발생하는 동작을 모니터링하거나 추적한다. 이를 통해 파일의 동적인 동작, 시스템 호출, 네트워크 통신 등을 분석할 수 있다.
                    <li>디컴파일 : 실행 파일의 기계어를 고급 언어로 변환하는 과정으로 프로그램의 소스 코드를 대략적으로 추정하고 분석할 수 있다.
                    <li>코드 역추적 : 분석된 코드를 이해하고 역으로 추적하여 원래의 설계나 알고리즘을 파악한다.
                    <li>악성 코드 분석 : 악성 코드 리버싱은 악성 소프트웨어의 동작 및 기능을 이해하고 대응 방법을 개발하기 위해 사용된다. 
                    </ol></ul></details>
            </div><hr>
            <div id="binary">
                <h3><strong>바이너리 코드와 보는 방법</strong></h3>
                <b><ins>바이너리 코드</ins></b><br>
                <p>: 바이너리 코드(Binary code)는 컴퓨터가 직접 이해하고 실행하는 형태의 0과 1로 구성된 코드이다. 컴퓨터 프로그램이나 파일은 컴파일러나 어셈블러에 의해 소스 코드로부터 
                    바이너리 코드로 변환된다. 바이너리 코드는 기계어 명령어로 이루어져 있으며, CPU가 이를 해석하여 프로그램을 실행한다. 
                </p>
                <b><ins>바이너리 코드 보는 방법</ins></b><br>
                <ul><li>헥스 에디터 사용 : 헥스 에디터(예 : Hex Fiend, HxD, xxd 등)를 실행하고 해당 프로그램으로 바이너리 파일을 열어 각 바이트의 값을 확인한다.
                <li>디버거 사용 : 디버거(예 : GDB, WinDbg, OllyDbg 등)를 실행하고 해당 프로그램으로 바이너리 파일을 로드하거나 실행 파일을 디버깅한다. 메모리 덤프 기능을 사용해 현재 실행 중인 프로세스의 메모리 내용을 보거나 
                    특정 주소의 바이너리 값을 확인할 수 있다.
                </ul>
            </div><hr>
        </section>
        <footer><h4>참고</h4>
            <ul><li>https://www.samsungsds.com/kr/insights/golang.html
                <li>ChatGPT
                <li><a href="1week1.html">1주차 첫번째 페이지로 이동</a>
            </ul>
        </footer>
    </body>
</html>